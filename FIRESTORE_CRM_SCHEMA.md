# Firestore CRM Schema - Address-Centric Design
**Generated:** December 23, 2025, 3:40 PM  
**Purpose:** Long-term system of record for address-based CRM operations  
**Design Principle:** Property/Address as central entity, not alert

---

## ðŸŽ¯ **SCHEMA OVERVIEW**

### Core Concept

**Traditional (Alert-Centric):**
```
Alert â†’ Extract Address â†’ Send to Sheets
```

**CRM-Grade (Address-Centric):**
```
Alert â†’ Property (canonical) â†’ Owner/Household â†’ Contacts â†’ Outreach Campaign
```

### Key Design Decisions

1. **Property is the canonical entity** (not alert)
2. **Stable identity** via normalized address + geocode
3. **Idempotent writes** via alert deduplication
4. **Relationship modeling** for owner/household/contacts
5. **Audit trail** for all enrichments and outreaches

---

## ðŸ“Š **PART 1: COLLECTIONS + DOCUMENT IDS**

### Collection 1: `/alerts/{alertId}`

**Purpose:** Raw alert events from mobile clients (append-only log)

**Document ID:** `alertId` = UUID generated by client

**Schema:**
```typescript
interface Alert {
  // Identity
  alertId: string;           // UUID from client
  sourceId: string;          // Which source captured this (BNN, SMS, etc)
  eventTimestamp: number;    // Unix millis when alert was received
  ingestedAt: number;        // Server timestamp when written to Firestore
  
  // Raw Data
  rawAddress: string;        // Address as it appeared in alert
  rawPayload: object;        // Full notification/SMS payload (title, text, etc)
  
  // Derived/Normalized
  propertyId?: string;       // FK to /properties/{propertyId} (set by server)
  normalizedAddress?: string; // USPS-normalized address (set by server)
  
  // Geo
  lat?: number;              // From geocoder (set by server)
  lng?: number;              // From geocoder (set by server)
  geocodeProvider?: string;  // "google" | "here" | "mapbox"
  geocodeConfidence?: string; // "rooftop" | "range_interpolated" | "geometric_center"
  
  // Metadata
  clientAppVersion?: string;
  clientDeviceId?: string;
  clientUserId?: string;
}
```

**Indexes:**
```
- alertId (auto, primary key)
- propertyId (composite with ingestedAt for property alert history)
- sourceId + eventTimestamp (for source-specific queries)
- ingestedAt (for time-based queries)
```

**Write Pattern:** Client writes, server enriches (`propertyId`, geocode)

**Retention:** Keep forever (audit trail)

---

### Collection 2: `/properties/{propertyId}`

**Purpose:** Canonical property/address records (one per unique address)

**Document ID:** `propertyId` = Deterministic hash of normalized address

**Generation:**
```typescript
// Pseudocode
function generatePropertyId(normalizedAddress: string): string {
  const canonical = normalizedAddress
    .toLowerCase()
    .replace(/[^a-z0-9]/g, '') // Remove non-alphanumeric
    .trim();
  return sha256(canonical).slice(0, 16); // 16-char hex
}
```

**Schema:**
```typescript
interface Property {
  // Identity
  propertyId: string;         // Hash of normalized address
  normalizedAddress: string;  // USPS-normalized "123 Main St, Austin, TX 78701"
  
  // Address Components
  streetNumber: string;       // "123"
  streetName: string;         // "Main St"
  city: string;               // "Austin"
  state: string;              // "TX"
  zipCode: string;            // "78701"
  county?: string;            // "Travis County"
  
  // Geo
  lat: number;
  lng: number;
  geocodeProvider: string;
  geocodeConfidence: string;
  placeId?: string;           // Google Place ID or equivalent
  
  // External IDs (for deduplication + enrichment)
  parcelId?: string;          // County parcel/APN
  attomId?: string;           // ATTOM property ID
  coreLogicId?: string;       // CoreLogic property ID
  
  // Property Details (from enrichment providers)
  propertyType?: string;      // "Single Family" | "Condo" | "Multi-Family"
  bedrooms?: number;
  bathrooms?: number;
  squareFeet?: number;
  yearBuilt?: number;
  lotSizeAcres?: number;
  assessedValue?: number;
  lastSaleDate?: string;      // ISO 8601
  lastSalePrice?: number;
  
  // CRM Metadata
  firstAlertAt: number;       // Unix millis of first alert
  lastAlertAt: number;        // Unix millis of most recent alert
  totalAlerts: number;        // Count of alerts for this property
  
  // Status
  enrichmentStatus: string;   // "pending" | "partial" | "complete" | "failed"
  enrichedAt?: number;        // When enrichment completed
  
  // Timestamps
  createdAt: number;          // Server timestamp
  updatedAt: number;          // Server timestamp
}
```

**Indexes:**
```
- propertyId (auto, primary key)
- normalizedAddress (unique, for exact match)
- city + state + zipCode (for geographic queries)
- lastAlertAt (for recent activity)
- enrichmentStatus (for batch processing)
- parcelId, attomId, coreLogicId (for external system lookups)
```

**Write Pattern:** Server-only (upserted on alert ingestion)

**Deduplication:** Hash of normalized address ensures one canonical record

---

### Collection 3: `/people/{personId}`

**Purpose:** Individual people (property owners, residents, contacts)

**Document ID:** `personId` = UUID or hash of (firstName + lastName + DOB)

**Schema:**
```typescript
interface Person {
  // Identity
  personId: string;
  
  // Name
  firstName: string;
  lastName: string;
  middleName?: string;
  suffix?: string;             // "Jr", "Sr", "III"
  
  // Demographics
  dateOfBirth?: string;        // ISO 8601 (YYYY-MM-DD)
  age?: number;
  gender?: string;
  
  // External IDs
  attomPersonId?: string;
  lexisNexisId?: string;
  
  // Metadata
  createdAt: number;
  updatedAt: number;
  enrichedAt?: number;
  enrichmentProvider?: string;  // "attom" | "lexisnexis" | "manual"
}
```

**Indexes:**
```
- personId (auto, primary key)
- lastName + firstName (for name search)
- attomPersonId, lexisNexisId (for external lookups)
```

**Write Pattern:** Server-only (created from enrichment providers)

---

### Collection 4: `/contacts/{contactId}`

**Purpose:** Phone numbers and email addresses (linked to people)

**Document ID:** `contactId` = Hash of (type + value)

**Schema:**
```typescript
interface Contact {
  // Identity
  contactId: string;           // Hash of phone/email
  
  // Contact Info
  type: string;                // "phone" | "email"
  value: string;               // "+15551234567" or "john@example.com"
  
  // Phone-Specific
  phoneType?: string;          // "mobile" | "landline" | "voip"
  carrier?: string;            // "Verizon" | "AT&T"
  
  // Email-Specific
  emailType?: string;          // "personal" | "work"
  
  // Linkage
  personId: string;            // FK to /people/{personId}
  
  // Consent & Compliance
  optInStatus: string;         // "opted-in" | "opted-out" | "unknown"
  optInDate?: number;          // Unix millis
  optOutDate?: number;         // Unix millis
  doNotContact: boolean;       // Hard block (legal/TCPA)
  
  // Quality
  verified: boolean;           // Has this contact been validated?
  verifiedAt?: number;
  verificationMethod?: string; // "sms-code" | "email-click" | "manual"
  
  // Metadata
  source: string;              // "attom" | "lexisnexis" | "manual"
  createdAt: number;
  updatedAt: number;
}
```

**Indexes:**
```
- contactId (auto, primary key)
- personId (to find all contacts for a person)
- value (for exact lookup by phone/email)
- type + optInStatus (for campaign targeting)
- type + doNotContact (to exclude blocked contacts)
```

**Write Pattern:** Server-only (from enrichment providers)

**Deduplication:** One record per unique phone/email

---

### Collection 5: `/households/{householdId}`

**Purpose:** Group people living at the same property

**Document ID:** `householdId` = UUID

**Schema:**
```typescript
interface Household {
  // Identity
  householdId: string;
  
  // Linkage
  propertyId: string;          // FK to /properties/{propertyId}
  memberIds: string[];         // Array of personId (members of household)
  
  // Roles
  primaryOwnerId?: string;     // personId of primary owner
  
  // Household Details
  householdSize?: number;
  householdIncome?: number;    // Estimated annual income
  
  // Timestamps
  createdAt: number;
  updatedAt: number;
}
```

**Indexes:**
```
- householdId (auto, primary key)
- propertyId (to find household for a property)
- memberIds (array-contains, to find households a person belongs to)
```

**Write Pattern:** Server-only (created after enrichment)

**Relationship:** Property 1:1 Household (one household per property)

---

### Collection 6: `/properties/{propertyId}/enrichments/{runId}`

**Purpose:** Store raw API responses from enrichment providers (subcollection)

**Document ID:** `runId` = Timestamp + provider name (e.g., `2025-12-23T15:30:00Z_attom`)

**Schema:**
```typescript
interface EnrichmentRun {
  // Identity
  runId: string;
  propertyId: string;          // Parent property
  
  // Provider
  provider: string;            // "attom" | "corelogic" | "lexisnexis"
  
  // Request
  requestedAt: number;
  requestPayload?: object;     // What was sent to provider
  
  // Response
  status: string;              // "success" | "partial" | "failed"
  responseCode?: number;       // HTTP status
  responsePayload?: object;    // Raw API response (store everything)
  errorMessage?: string;
  
  // Extracted Data
  ownerName?: string;
  ownerNames?: string[];       // If multiple owners
  phoneNumbers?: string[];
  emailAddresses?: string[];
  
  // Costs
  apiCallCost?: number;        // Cost in cents
  
  // Timestamps
  completedAt?: number;
}
```

**Indexes:**
```
- runId (auto, primary key)
- provider + requestedAt (for audit trail)
- status (to find failed enrichments)
```

**Write Pattern:** Server-only (one doc per enrichment API call)

**Purpose:** Audit trail + ability to re-process if needed

---

### Collection 7: `/outreaches/{outreachId}`

**Purpose:** Outreach campaign instances (email/SMS sent to property owner)

**Document ID:** `outreachId` = UUID

**Schema:**
```typescript
interface Outreach {
  // Identity
  outreachId: string;
  
  // Linkage
  propertyId: string;          // FK to /properties/{propertyId}
  personId: string;            // FK to /people/{personId} (recipient)
  contactId: string;           // FK to /contacts/{contactId} (phone/email used)
  householdId?: string;        // FK to /households/{householdId}
  
  // Campaign
  campaignId?: string;         // If part of bulk campaign
  campaignName?: string;       // "Fire Alert Follow-Up Q4 2025"
  
  // Message
  messageType: string;         // "sms" | "email"
  templateId?: string;         // Which template was used
  messageContent: string;      // Actual message sent (with variables filled)
  
  // Status
  status: string;              // "queued" | "sent" | "delivered" | "failed" | "bounced"
  
  // Provider
  provider: string;            // "twilio" | "sendgrid" | "mailgun"
  providerMessageId?: string;  // External ID from provider
  
  // Delivery
  queuedAt: number;            // When queued
  sentAt?: number;             // When sent to provider
  deliveredAt?: number;        // When provider confirmed delivery
  failedAt?: number;
  errorMessage?: string;
  
  // Engagement
  openedAt?: number;           // Email opened (if tracked)
  clickedAt?: number;          // Link clicked
  repliedAt?: number;          // User replied
  
  // Costs
  messageCost?: number;        // Cost in cents
  
  // Timestamps
  createdAt: number;
  updatedAt: number;
}
```

**Indexes:**
```
- outreachId (auto, primary key)
- propertyId + sentAt (for property outreach history)
- personId + sentAt (for person communication history)
- campaignId + status (for campaign tracking)
- status + queuedAt (for retry queue)
- provider + providerMessageId (for webhook lookups)
```

**Write Pattern:** Server-only (created by outreach engine)

---

### Collection 8: `/messages/{messageId}`

**Purpose:** Individual communication logs (SMS/email) with full provider metadata

**Document ID:** `messageId` = Provider message ID or UUID

**Schema:**
```typescript
interface Message {
  // Identity
  messageId: string;           // UUID or provider ID
  outreachId: string;          // FK to /outreaches/{outreachId}
  
  // Type
  direction: string;           // "outbound" | "inbound"
  messageType: string;         // "sms" | "email"
  
  // Content
  from: string;                // Phone/email sender
  to: string;                  // Phone/email recipient
  subject?: string;            // Email subject
  body: string;                // Message content
  
  // Provider
  provider: string;            // "twilio" | "sendgrid"
  providerMessageId: string;   // External ID
  providerStatus: string;      // Raw provider status
  providerResponse?: object;   // Full provider webhook payload
  
  // Timestamps
  sentAt?: number;
  deliveredAt?: number;
  readAt?: number;
  errorAt?: number;
  errorMessage?: string;
  
  // Metadata
  createdAt: number;
  updatedAt: number;
}
```

**Indexes:**
```
- messageId (auto, primary key)
- outreachId (to group messages by outreach)
- providerMessageId (for webhook routing)
- direction + sentAt (for activity timeline)
```

---

## ðŸ“Š **PART 2: RELATIONSHIPS + QUERY PATTERNS**

### Relationship Diagram

```
Alert (many) â†’ Property (one)
Property (one) â†’ Household (one)
Household (one) â†’ People (many)
Person (one) â†’ Contacts (many)
Property (one) â†’ Enrichments (many, subcollection)
Property (one) â†’ Outreaches (many)
Outreach (one) â†’ Messages (many)
```

---

### Query Pattern 1: "Given alert â†’ get property â†’ get owner â†’ get phone/email â†’ last outreach status"

**Step 1:** Lookup property from alert
```typescript
const alert = await db.collection('alerts').doc(alertId).get();
const propertyId = alert.data().propertyId;
```

**Step 2:** Get property
```typescript
const property = await db.collection('properties').doc(propertyId).get();
```

**Step 3:** Get household
```typescript
const household = await db.collection('households')
  .where('propertyId', '==', propertyId)
  .limit(1)
  .get();
const primaryOwnerId = household.docs[0].data().primaryOwnerId;
```

**Step 4:** Get owner person
```typescript
const owner = await db.collection('people').doc(primaryOwnerId).get();
```

**Step 5:** Get contacts
```typescript
const contacts = await db.collection('contacts')
  .where('personId', '==', primaryOwnerId)
  .where('type', '==', 'phone')
  .where('optInStatus', '==', 'opted-in')
  .where('doNotContact', '==', false)
  .get();
```

**Step 6:** Get last outreach
```typescript
const lastOutreach = await db.collection('outreaches')
  .where('propertyId', '==', propertyId)
  .orderBy('sentAt', 'desc')
  .limit(1)
  .get();
```

**Index Required:**
```
outreaches: propertyId + sentAt (DESC)
contacts: personId + type + optInStatus + doNotContact
households: propertyId
```

---

### Query Pattern 2: "All properties with alerts in last 7 days, no outreach yet"

```typescript
const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);

const recentProperties = await db.collection('properties')
  .where('lastAlertAt', '>=', sevenDaysAgo)
  .get();

for (const prop of recentProperties.docs) {
  const propertyId = prop.id;
  
  const hasOutreach = await db.collection('outreaches')
    .where('propertyId', '==', propertyId)
    .where('sentAt', '>=', sevenDaysAgo)
    .limit(1)
    .get();
  
  if (hasOutreach.empty) {
    // Property has alert but no outreach â†’ candidate for campaign
  }
}
```

**Index Required:**
```
properties: lastAlertAt
outreaches: propertyId + sentAt
```

---

### Query Pattern 3: "Properties by city/zip needing enrichment"

```typescript
const pendingEnrichment = await db.collection('properties')
  .where('city', '==', 'Austin')
  .where('state', '==', 'TX')
  .where('enrichmentStatus', '==', 'pending')
  .limit(100)
  .get();
```

**Index Required:**
```
properties: city + state + enrichmentStatus
```

---

### Query Pattern 4: "Dedupe: Is this address already in system?"

```typescript
function normalizeAddress(rawAddress: string): string {
  // USPS standardization logic
  return normalized;
}

const normalized = normalizeAddress(rawAddress);
const propertyId = generatePropertyId(normalized);

const existing = await db.collection('properties').doc(propertyId).get();

if (existing.exists) {
  // Duplicate - update lastAlertAt, increment totalAlerts
  await existing.ref.update({
    lastAlertAt: Date.now(),
    totalAlerts: admin.firestore.FieldValue.increment(1)
  });
} else {
  // New property - create
  await db.collection('properties').doc(propertyId).set({
    propertyId,
    normalizedAddress: normalized,
    // ...
    firstAlertAt: Date.now(),
    lastAlertAt: Date.now(),
    totalAlerts: 1
  });
}
```

**No index required** (doc ID lookup)

---

## ðŸ“Š **PART 3: SECURITY RULES APPROACH**

### Principle: Client Writes Alerts Only, Server Enriches CRM Docs

```javascript
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // === ALERTS: Client can write, server can read/enrich ===
    match /alerts/{alertId} {
      // Client can create alerts (append-only)
      allow create: if request.auth != null
                    && request.resource.data.alertId == alertId
                    && request.resource.data.sourceId is string
                    && request.resource.data.rawAddress is string
                    && request.resource.data.eventTimestamp is number
                    && request.resource.data.ingestedAt == request.time.toMillis();
      
      // Client can read own alerts
      allow read: if request.auth != null
                  && request.auth.uid == resource.data.clientUserId;
      
      // Server can update to add propertyId, geocode, etc.
      allow update: if request.auth.token.admin == true; // Cloud Function service account
    }
    
    // === PROPERTIES: Server-only ===
    match /properties/{propertyId} {
      allow read: if request.auth != null; // Authenticated users can read
      allow write: if request.auth.token.admin == true; // Only server
      
      // Enrichment subcollection
      match /enrichments/{runId} {
        allow read: if request.auth != null;
        allow write: if request.auth.token.admin == true;
      }
    }
    
    // === PEOPLE: Server-only ===
    match /people/{personId} {
      allow read: if request.auth != null;
      allow write: if request.auth.token.admin == true;
    }
    
    // === CONTACTS: Server-only ===
    match /contacts/{contactId} {
      allow read: if request.auth != null;
      allow write: if request.auth.token.admin == true;
    }
    
    // === HOUSEHOLDS: Server-only ===
    match /households/{householdId} {
      allow read: if request.auth != null;
      allow write: if request.auth.token.admin == true;
    }
    
    // === OUTREACHES: Server-only ===
    match /outreaches/{outreachId} {
      allow read: if request.auth != null;
      allow write: if request.auth.token.admin == true;
    }
    
    // === MESSAGES: Server-only ===
    match /messages/{messageId} {
      allow read: if request.auth != null;
      allow write: if request.auth.token.admin == true;
    }
  }
}
```

### Key Rules

1. **Clients can only write `/alerts`** (append-only)
2. **Clients can read their own data** (via `clientUserId`)
3. **All CRM collections are server-only** (`admin == true` token claim)
4. **No client can modify property/person/contact data**

---

## ðŸ“Š **PART 4: WRITE FLOW (CLIENT â†’ SERVER â†’ CRM)**

### Client-Side Write (Android App)

```kotlin
// IngestQueue.kt
fun enqueue(sourceId: String, payload: Map<String, Any>, timestamp: Long): String {
    val alertId = UUID.randomUUID().toString()
    val userId = FirebaseAuth.getInstance().currentUser?.uid
    
    val alert = mapOf(
        "alertId" to alertId,
        "sourceId" to sourceId,
        "rawAddress" to payload["address"],
        "rawPayload" to payload,
        "eventTimestamp" to timestamp,
        "ingestedAt" to FieldValue.serverTimestamp(),
        "clientUserId" to userId,
        "clientAppVersion" to BuildConfig.VERSION_NAME
    )
    
    firestore.collection("alerts").document(alertId).set(alert)
    
    return alertId
}
```

---

### Server-Side Pipeline (Cloud Function)

```typescript
// functions/src/ingest.ts

export const processAlert = functions.firestore
  .document('alerts/{alertId}')
  .onCreate(async (snap, context) => {
    const alert = snap.data();
    const alertId = context.params.alertId;
    
    try {
      // STEP 1: Geocode address
      const geocoded = await geocodeAddress(alert.rawAddress);
      
      // STEP 2: Normalize address
      const normalized = normalizeAddress(geocoded);
      
      // STEP 3: Generate property ID (deterministic)
      const propertyId = generatePropertyId(normalized);
      
      // STEP 4: Upsert property
      const propertyRef = db.collection('properties').doc(propertyId);
      const propertySnap = await propertyRef.get();
      
      if (propertySnap.exists) {
        // Update existing property
        await propertyRef.update({
          lastAlertAt: alert.eventTimestamp,
          totalAlerts: admin.firestore.FieldValue.increment(1),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
      } else {
        // Create new property
        await propertyRef.set({
          propertyId,
          normalizedAddress: normalized,
          streetNumber: geocoded.streetNumber,
          streetName: geocoded.streetName,
          city: geocoded.city,
          state: geocoded.state,
          zipCode: geocoded.zipCode,
          lat: geocoded.lat,
          lng: geocoded.lng,
          geocodeProvider: geocoded.provider,
          geocodeConfidence: geocoded.confidence,
          firstAlertAt: alert.eventTimestamp,
          lastAlertAt: alert.eventTimestamp,
          totalAlerts: 1,
          enrichmentStatus: 'pending',
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
          updatedAt: admin.firestore.FieldValue.serverTimestamp()
        });
      }
      
      // STEP 5: Update alert with propertyId
      await snap.ref.update({
        propertyId,
        normalizedAddress: normalized,
        lat: geocoded.lat,
        lng: geocoded.lng,
        geocodeProvider: geocoded.provider,
        geocodeConfidence: geocoded.confidence
      });
      
      // STEP 6: Trigger enrichment (async)
      await triggerEnrichment(propertyId);
      
    } catch (error) {
      console.error(`Error processing alert ${alertId}:`, error);
      await snap.ref.update({
        processingError: error.message,
        processingFailedAt: admin.firestore.FieldValue.serverTimestamp()
      });
    }
  });
```

---

### Enrichment Pipeline (Cloud Run)

```typescript
// Triggered by new property or scheduled batch
export async function enrichProperty(propertyId: string) {
  const propertyRef = db.collection('properties').doc(propertyId);
  const property = (await propertyRef.get()).data();
  
  // STEP 1: Call ATTOM API
  const runId = `${new Date().toISOString()}_attom`;
  const enrichmentRef = propertyRef.collection('enrichments').doc(runId);
  
  try {
    const attomResponse = await callAttomAPI({
      address: property.normalizedAddress,
      city: property.city,
      state: property.state,
      zipCode: property.zipCode
    });
    
    // Store raw response
    await enrichmentRef.set({
      runId,
      propertyId,
      provider: 'attom',
      requestedAt: Date.now(),
      status: 'success',
      responsePayload: attomResponse,
      completedAt: Date.now()
    });
    
    // Extract owner info
    const ownerName = attomResponse.property.owner.name;
    const ownerNames = ownerName.split(' AND '); // Multiple owners
    
    // STEP 2: Create/update Person records
    const personIds = [];
    for (const name of ownerNames) {
      const personId = await upsertPerson(name, attomResponse);
      personIds.push(personId);
    }
    
    // STEP 3: Create/update Contact records (phones/emails)
    for (const personId of personIds) {
      if (attomResponse.property.owner.phone) {
        await upsertContact(personId, 'phone', attomResponse.property.owner.phone, 'attom');
      }
      if (attomResponse.property.owner.email) {
        await upsertContact(personId, 'email', attomResponse.property.owner.email, 'attom');
      }
    }
    
    // STEP 4: Create/update Household
    await upsertHousehold(propertyId, personIds);
    
    // STEP 5: Update property enrichment status
    await propertyRef.update({
      enrichmentStatus: 'complete',
      enrichedAt: Date.now(),
      parcelId: attomResponse.property.parcelId,
      attomId: attomResponse.property.attomId,
      propertyType: attomResponse.property.propertyType,
      // ... other property details
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
  } catch (error) {
    await enrichmentRef.set({
      runId,
      propertyId,
      provider: 'attom',
      requestedAt: Date.now(),
      status: 'failed',
      errorMessage: error.message,
      completedAt: Date.now()
    });
    
    await propertyRef.update({
      enrichmentStatus: 'failed',
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
  }
}
```

---

### Outreach Trigger (Cloud Run Scheduled Task)

```typescript
// Runs daily to find properties needing outreach
export async function dailyOutreachCampaign() {
  const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
  
  // Find properties with recent alerts but no outreach
  const candidates = await db.collection('properties')
    .where('lastAlertAt', '>=', sevenDaysAgo)
    .where('enrichmentStatus', '==', 'complete')
    .get();
  
  for (const propDoc of candidates.docs) {
    const propertyId = propDoc.id;
    
    // Check if already contacted
    const existingOutreach = await db.collection('outreaches')
      .where('propertyId', '==', propertyId)
      .where('sentAt', '>=', sevenDaysAgo)
      .limit(1)
      .get();
    
    if (!existingOutreach.empty) continue; // Already contacted
    
    // Get household
    const household = await db.collection('households')
      .where('propertyId', '==', propertyId)
      .limit(1)
      .get();
    
    if (household.empty) continue; // No owner info
    
    const primaryOwnerId = household.docs[0].data().primaryOwnerId;
    
    // Get opted-in phone
    const contacts = await db.collection('contacts')
      .where('personId', '==', primaryOwnerId)
      .where('type', '==', 'phone')
      .where('optInStatus', '==', 'opted-in')
      .where('doNotContact', '==', false)
      .limit(1)
      .get();
    
    if (contacts.empty) continue; // No valid contact
    
    const contact = contacts.docs[0].data();
    
    // Create outreach
    const outreachId = db.collection('outreaches').doc().id;
    await db.collection('outreaches').doc(outreachId).set({
      outreachId,
      propertyId,
      personId: primaryOwnerId,
      contactId: contact.contactId,
      householdId: household.docs[0].id,
      campaignId: 'fire-alert-q4-2025',
      campaignName: 'Fire Alert Follow-Up Q4 2025',
      messageType: 'sms',
      templateId: 'fire-followup-v1',
      messageContent: `Hi, we noticed a fire alert at ${propDoc.data().normalizedAddress}. Reply YES for more info.`,
      status: 'queued',
      provider: 'twilio',
      queuedAt: Date.now(),
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });
    
    // Trigger SMS send
    await sendSMS(outreachId);
  }
}
```

---

## ðŸ“Š **PART 5: MIGRATION FROM CURRENT INGEST DOCS**

### Current Schema (If Any)

```typescript
// Current /ingest collection (from harness)
interface CurrentIngestDoc {
  eventId: string;
  sourceId: string;
  payload: object;
  timestamp: number;
  status: string; // "success" | "failed"
}
```

### Migration Strategy

#### Option A: One-Time Backfill

```typescript
// Cloud Function (run once)
export async function migrateIngestToAlerts() {
  const ingestDocs = await db.collection('ingest').get();
  
  for (const doc of ingestDocs.docs) {
    const oldData = doc.data();
    
    // Map to new alert schema
    const alert = {
      alertId: oldData.eventId,
      sourceId: oldData.sourceId,
      rawAddress: oldData.payload.address || 'Unknown',
      rawPayload: oldData.payload,
      eventTimestamp: oldData.timestamp,
      ingestedAt: oldData.timestamp, // Use original timestamp
      clientUserId: null, // No user tracking in old version
      clientAppVersion: 'legacy'
    };
    
    // Write to /alerts
    await db.collection('alerts').doc(alert.alertId).set(alert);
    
    // Trigger property creation
    await processAlert(alert);
  }
  
  console.log(`Migrated ${ingestDocs.size} ingest docs to alerts`);
}
```

#### Option B: Dual-Write (Transition Period)

```kotlin
// Android app - write to BOTH collections temporarily
fun enqueue(sourceId: String, payload: Map<String, Any>, timestamp: Long): String {
    val eventId = UUID.randomUUID().toString()
    
    // Write to OLD schema (for backward compatibility)
    firestore.collection("ingest").document(eventId).set(mapOf(
        "eventId" to eventId,
        "sourceId" to sourceId,
        "payload" to payload,
        "timestamp" to timestamp
    ))
    
    // Write to NEW schema
    firestore.collection("alerts").document(eventId).set(mapOf(
        "alertId" to eventId,
        "sourceId" to sourceId,
        "rawAddress" to payload["address"],
        "rawPayload" to payload,
        "eventTimestamp" to timestamp,
        "ingestedAt" to FieldValue.serverTimestamp(),
        "clientUserId" to FirebaseAuth.getInstance().currentUser?.uid
    ))
    
    return eventId
}
```

**Duration:** 2 weeks (verify new schema, then remove old writes)

---

## ðŸŽ¯ **SUMMARY**

### Collections

| Collection | Purpose | Write Access | Document Count (Est) |
|------------|---------|--------------|----------------------|
| `/alerts` | Raw alert events | Client + Server | ~10K/month |
| `/properties` | Canonical addresses | Server-only | ~2-5K unique |
| `/people` | Property owners | Server-only | ~3-8K |
| `/contacts` | Phone/email | Server-only | ~5-15K |
| `/households` | Property-owner linkage | Server-only | ~2-5K |
| `/properties/.../enrichments` | API call audit trail | Server-only | ~5-10K |
| `/outreaches` | Campaign instances | Server-only | ~5-20K/month |
| `/messages` | Communication logs | Server-only | ~5-20K/month |

### Key Features

âœ… **Stable identity:** Properties use deterministic hash of normalized address  
âœ… **Idempotent:** Duplicate alerts update existing property, don't create new  
âœ… **Audit trail:** All enrichments and messages logged  
âœ… **Relationships:** Property â†’ Household â†’ People â†’ Contacts â†’ Outreaches  
âœ… **Privacy:** Opt-out tracking, do-not-contact flags  
âœ… **Scalable:** Indexed for common queries  
âœ… **Secure:** Clients write alerts only, server manages CRM  

---

**END OF FIRESTORE_CRM_SCHEMA.md**

